trigger:
  - main

pool:
  name: 'Default'
  demands:
    - agent.os -equals linux
    - agent.name -equals quadz-customer-prod-vm

variables:
  - group: TerraformSecrets

steps:
# Step 1: Checkout code
- checkout: self

# Step 2: Check if Terraform files have changed
- script: |
    echo "Checking for changes in Terraform files..."
    git diff --name-only HEAD~1 HEAD | grep -E '(\.tf$|\.tfvars$)' > changed_files.txt
    if [ -s changed_files.txt ]; then
      echo "Terraform files changed. Proceeding with Terraform steps."
      echo "##vso[task.setvariable variable=terraform_changed]true"
    else
      echo "No changes to Terraform files. Skipping Terraform steps."
      echo "##vso[task.setvariable variable=terraform_changed]false"
    fi
  displayName: 'Check for Terraform File Changes'

# Step 3: Terraform Init (runs only if there are changes to Terraform files)
- script: |
    if [ "$(terraform_changed)" == "true" ]; then
      cd /home/quadz/node-hello
      terraform init
    else
      echo "Skipping Terraform Init."
    fi
  displayName: 'Terraform Init'

# Step 4: Terraform Plan using default.tfvars (runs only if there are changes to Terraform files)
- script: |
    if [ "$(terraform_changed)" == "true" ]; then
      cd /home/quadz/node-hello
      terraform plan -var-file=default.tfvars -out=tfplan
    else
      echo "Skipping Terraform Plan."
    fi
  displayName: 'Terraform Plan'

# Step 5: Terraform Apply (runs only if there are changes to Terraform files)
- script: |
    if [ "$(terraform_changed)" == "true" ]; then
      cd /home/quadz/node-hello
      terraform apply -auto-approve tfplan
    else
      echo "Skipping Terraform Apply."
    fi
  displayName: 'Terraform Apply'

# Step 6: Get VM IP Address (this step should run regardless of Terraform changes)
- script: |
    cd /home/quadz/node-hello
    terraform refresh -var-file=default.tfvars
    terraform output vm_ip
    export VM_IP=$(terraform output -raw vm_ip)
    echo "VM IP: $VM_IP"
    echo "##vso[task.setvariable variable=VM_IP]$VM_IP"
  displayName: 'Get VM Public IP'

# Step 7: Wait for VM to be ready (always runs)
- script: |
    echo "Waiting for VM to be ready..."
    sleep 5
  displayName: 'Waiting for VM to be Ready'

# Step 8: SSH into VM and Deploy Node.js Application (always runs)
- script: |
    echo "Attempting to SSH into the VM..."
    if [ -z "$VM_IP" ]; then
      echo "Error: VM_IP is not set."
      exit 1
    fi

    if ! [[ "$VM_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      echo "Error: Invalid IP address format: $VM_IP"
      exit 1
    fi

    if [ -z "$VM_USERNAME" ] || [ -z "$VM_PASSWORD" ]; then
      echo "Error: VM_USERNAME or VM_PASSWORD is not set."
      exit 1
    fi

    sudo apt-get update && sudo apt-get install -y sshpass

    sshpass -p "$VM_PASSWORD" rsync -avz -e "ssh -o StrictHostKeyChecking=no" ./ "$VM_USERNAME@$VM_IP:/home/$VM_USERNAME/node-hello"

    sshpass -p "$VM_PASSWORD" ssh -o StrictHostKeyChecking=no "$VM_USERNAME@$VM_IP" "
      sudo apt update && 
      sudo apt install -y curl &&
      curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - &&
      sudo apt install -y nodejs &&
      cd /home/$VM_USERNAME/node-hello && \
      npm install && \
      sudo npm install -g pm2 && \
      # Check if the application is running
      if pm2 show 'app' > /dev/null; then
          # If the app is running, restart it
          echo "App is already running. Restarting..."
          pm2 restart 'app'
      else
          # If the app is not running, start it
          echo "App is not running. Starting the app..."
          pm2 start npm --name 'app' -- start
      fi && \
      pm2 save && \
      pm2 ls
    "
  displayName: 'SSH into VM and Deploy Application'
